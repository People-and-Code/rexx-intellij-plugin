{
    parserClass="se.peopleandcode.rexxintellijplugin.gen.RexxParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Rexx"
    psiImplClassSuffix="Impl"
    psiPackage="se.peopleandcode.rexxintellijplugin.gen.psi"
    psiImplPackage="se.peopleandcode.rexxintellijplugin.gen.impl"
    elementTypeHolderClass="se.peopleandcode.rexxintellijplugin.gen.RexxTokens"
    elementTypeClass="se.peopleandcode.rexxintellijplugin.RexxElementType"
    tokenTypeClass="se.peopleandcode.rexxintellijplugin.RexxTokenType"
    tokens=[
        WHITE_SPACE="regexp:([ \t]|,[\n])+"
        TERMINATOR="regexp:[\n;]+"
        // MAJOR TOKEN TYPES
        // TOKEN_NULL
        //     TOKEN_BLANK
        //     TOKEN_SYMBOL
        //     TOKEN_LITERAL
        //     TOKEN_OPERATOR
        //     TOKEN_EOC
        //     TOKEN_COMMA
        //     TOKEN_PREFIX
        TOKEN_LEFT="("
        TOKEN_RIGHT=")"
        //     TOKEN_POINT
        //     TOKEN_COLON
        //     TOKEN_TILDE
        //     TOKEN_DTILDE
        //     TOKEN_SQLEFT
        //     TOKEN_SQRIGHT
        //     TOKEN_DCOLON
        //     TOKEN_CONTINUE
        //     TOKEN_ASSIGNMENT

        // OPERATORS
        OPERATOR_PLUS="regexp:[+]"
        OPERATOR_SUBTRACT="regexp:-"
        OPERATOR_MULTIPLY="regexp:[*]"
        OPERATOR_DIVIDE="regexp:/"
        //OPERATOR_INTDIV="regexp:\\\\"
        OPERATOR_REMAINDER="regexp:%"
        OPERATOR_POWER="regexp:[*][*]"
        OPERATOR_CONCATENATE="regexp:[|][|]"
        OPERATOR_AND="regexp:&&"

        // Bitwise
        OPERATOR_BITWISE_AND="regexp:&"
        OPERATOR_OR="regexp:[|]"
        OPERATOR_XOR="regexp:\^\^"

        OPERATOR_EQUAL="regexp:="
        OPERATOR_NOT_EQUAL="regexp:<>|><|[\\]=|Â¬="
        OPERATOR_GREATERTHAN="regexp:>"
        OPERATOR_BACKSLASH_GREATERTHAN="regexp:\\>"
        OPERATOR_LESSTHAN="regexp:<"
        OPERATOR_BACKSLASH_LESSTHAN="regexp:\\<"
        OPERATOR_GREATERTHAN_EQUAL="regexp:>="
        OPERATOR_LESSTHAN_EQUAL="regexp:=<"

        OPERATOR_STRICT_EQUAL="regexp:=="
        OPERATOR_STRICT_BACKSLASH_EQUAL="regexp:\\=="
        // OPERATOR_STRICT_GREATERTHAN="regexp:==>"
        OPERATOR_STRICT_BACKSLASH_GREATERTHAN="regexp:\\==>"
        OPERATOR_STRICT_LESSTHAN="regexp:==<"
        OPERATOR_STRICT_BACKSLASH_LESSTHAN="regexp:\\==<"
        OPERATOR_STRICT_GREATERTHAN_EQUAL="regexp:==>"
        OPERATOR_STRICT_LESSTHAN_EQUAL="regexp:==<="
        OPERATOR_LESSTHAN_GREATERTHAN="regexp:<>"
        OPERATOR_GREATERTHAN_LESSTHAN="regexp:><"

        OPERATOR_BACKSLASH="regexp:\\\\"

        KEYWORD_ADDRESS="regexp:[Aa][Dd][Dd][Rr][Ee][Ss][Ss]"
        KEYWORD_ARG="regexp:[Aa][Rr][Gg]"
        KEYWORD_VAR="regexp:[Vv][Aa][Rr]"
        KEYWORD_VALUE="regexp:[Vv][Aa][Ll][Uu][Ee]"
        KEYWORD_WITH="regexp:[Ww][Ii][Tt][Hh]"
        KEYWORD_CALL="regexp:[Cc][Aa][Ll][Ll]"
        KEYWORD_DO="regexp:[Dd][Oo]"
        KEYWORD_DROP="regexp:[Dd][Rr][Oo][Pp]"
        KEYWORD_ELSE="regexp:[Ee][Ll][Ss][Ee]"
        KEYWORD_END="regexp:[Ee][Nn][Dd]"
        KEYWORD_EXIT="regexp:[Ee][Xx][Ii][Tt]"
        KEYWORD_EXPOSE="regexp:[Ee][Xx][Pp][Oo][Ss][Ee]"
        KEYWORD_FORWARD="regexp:[Ff][Oo][Rr][Ww][Aa][Rr][Dd]"
        KEYWORD_GUARD="regexp:[Gg][Uu][Aa][Rr][Dd]"
        KEYWORD_IF="regexp:[Ii][Ff]"
        KEYWORD_INTERPRET="regexp:[Ii][Nn][Tt][Ee][Rr][Pp][Rr][Ee][Tt]"
        KEYWORD_ITERATE="regexp:[Ii][Tt][Ee][Rr][Aa][Tt][Ee]"
        KEYWORD_LEAVE="regexp:[Ll][Ee][Aa][Vv][Ee]"
        KEYWORD_LOOP="regexp:[Ll][Oo][Oo][Pp]"
        KEYWORD_NOP="regexp:[Nn][Oo][Pp]"
        KEYWORD_NUMERIC="regexp:[Nn][Uu][Mm][Ee][Rr][Ii][Cc]"
        KEYWORD_OPTIONS="regexp:[Oo][Pp][Tt][Ii][Oo][Nn][Ss]"
        KEYWORD_OTHERWISE="regexp:[Oo][Tt][Hh][Ee][Rr][Ww][Ii][Ss][Ee]"
        KEYWORD_PARSE="regexp:[Pp][Aa][Rr][Ss][Ee]"
        KEYWORD_PROCEDURE="regexp:[Pp][Rr][Oo][Cc][Ee][Dd][Uu][Rr][Ee]"
        KEYWORD_PULL="regexp:[Pp][Uu][Ll][Ll]"
        KEYWORD_PUSH="regexp:[Pp][Uu][Ss][Hh]"
        KEYWORD_QUEUE="regexp:[Qq][Uu][Ee][Uu][Ee]"
        KEYWORD_RAISE="regexp:[Rr][Aa][Ii][Ss][Ee]"
        KEYWORD_REPLY="regexp:[Rr][Ee][Pp][Ll][Yy]"
        KEYWORD_RETURN="regexp:[Rr][Ee][Tt][Uu][Rr][Nn]"
        KEYWORD_SAY="regexp:[Ss][Aa][Yy]"
        KEYWORD_SELECT="regexp:[Ss][Ee][Ll][Ee][Cc][Tt]"
        KEYWORD_SOURCE="regexp:[Ss][Oo][Uu][Rr][Cc][Ee]"
        KEYWORD_SIGNAL="regexp:[Ss][Ii][Gg][Nn][Aa][Ll]"
        KEYWORD_THEN="regexp:[Tt][Hh][Ee][Nn]"
        KEYWORD_TRACE="regexp:[Tt][Rr][Aa][Cc][Ee]"
        KEYWORD_USE="regexp:[Uu][Ss][Ee]"
        KEYWORD_WHILE="regexp:[Ww][Hh][Ii][Ll][Ee]"
        //KEYWORD_WHEN="regexp:WHEN"


        // Comments
        SHEBANG="regexp:[#][!][^\n]*"
        LINE_COMMENT="regexp:--[^\n]*"
        MULTILINE_COMMENT="regexp:[/][*]([^*]+|[*]+[^/*])*[*]+[/]"

        // complex

        STRING="regexp:\"[^\"\n]*\"|'[^'\n]*'"
        IDENTIFIER="regexp:[a-zA-Z][a-zA-Z0-9_]*"


        // Numbers
        NUMBER_BINARY="regexp:0b[01]+"
        NUMBER_INT="regexp:[0-9]+"
        NUMBER_DECIMAL="regexp:[0-9]+[.][0-9]+"
        NUMBER_SCIENTIFIC="regexp:[0-9]*[.][0-9]+([eE][+-]?[0-9]+)"
        NUMBER_HEXADECIMAL="regexp:0[xX][0-9a-fA-F]+"

        // OO

        KEYWORD_CLASS="regexp:::class"
        KEYWORD_ATTRIBUTE="regexp:::attribute"
        KEYWORD_METHOD="regexp:::method"
        DOT="regexp:[.]"
        EXCLAMATION="regexp:[!]"
        TILDE="regexp:[~]"
        COMMA="regexp:[,]"
        COLON="regexp:[:]"
    ]
}

/*program*/
rexx_file ::= ncl? instruction_list? KEYWORD_END?
private ncl ::=  <<eof>> | null_clause+
private null_clause ::= terminator /*label_list?
private label_list ::= (label_instruction terminator)+*/
private terminator ::= <<eof>> | TERMINATOR
private instruction_list ::= instruction+
private instruction ::= group | single_instruction ncl
private group ::= instruction_block | if_instruction /* | select */
private command ::= expression_instruction
private keyword_instruction
    ::= address_instruction
    /*| arg*/
    | call_instruction
    /*| drop*/
    | exit_instruction
    /*| interop*/
    /*| iterate*/
    /*| leave*/
    /*| nop*/
    | numeric_instruction
    /*| options*/
    | parse_instruction
    /*| procedure */
    | return_instruction
    | say_instruction
    | signal_instruction
    | trace_instruction
private single_instruction
    ::= label_instruction
    | assignment
    | keyword_instruction
    | command
private parse_instruction
    ::= parse_arg_instruction
    | parse_pull_instruction
    | parse_var_instruction
    | parse_value_instruction
    | parse_source_instruction
numeric_instruction ::= KEYWORD_NUMERIC IDENTIFIER integerConstant
label_instruction ::= name_declaration COLON (KEYWORD_PROCEDURE (KEYWORD_EXPOSE IDENTIFIER)? DOT?)?
return_instruction ::= KEYWORD_RETURN expression?

signal_instruction ::= KEYWORD_SIGNAL expressions

trace_instruction ::= KEYWORD_TRACE ("o"|"i"|"r")

exit_instruction ::= KEYWORD_EXIT expression?

call_instruction ::= KEYWORD_CALL IDENTIFIER comma_seperated_arguments

address_instruction ::= KEYWORD_ADDRESS expressions

expression_instruction
    ::= &IDENTIFIER expression
    | &stringLiteral expression


instruction_block ::= do_specification ncl
    instruction_list?
    do_ending
private do_specification ::= KEYWORD_DO /*[group_option+]*/
    ( dorep
    | conditional
    | dorep conditional
    )?
private conditional ::= 'WHILE' whileexpr | 'UNTIL' untilexpr
private untilexpr ::= expression
private whileexpr ::= expression
private dorep ::= 'FORVER' | repetitor
private repetitor ::= assignment | expression | over | 'FOREVER'
private over
    ::= name_declaration 'OVER' expression
    | numericConstant 'OVER'
    /*| CONST_SYMBOL 'OVER'*/
private do_ending ::= KEYWORD_END name_declaration? ncl
parse_pull_instruction ::= KEYWORD_PARSE KEYWORD_PULL parse_target* (COMMA parse_target*)*
parse_arg_instruction ::= KEYWORD_PARSE KEYWORD_ARG parse_target* (COMMA parse_target*)*
parse_var_instruction ::= KEYWORD_PARSE KEYWORD_VAR parse_target*
parse_value_instruction ::= KEYWORD_PARSE KEYWORD_VALUE expression KEYWORD_WITH parse_target*
parse_source_instruction ::= KEYWORD_PARSE KEYWORD_SOURCE parse_target*
private parse_target
    ::= IDENTIFIER DOT EXCLAMATION? IDENTIFIER
    | name_declaration
    | stringLiteral
    | integerConstant
    | remainder // | range | offset

remainder ::= DOT
if_instruction ::= KEYWORD_IF expression ncl? then else?
private then ::= KEYWORD_THEN ncl? (instruction | END)
private else ::= KEYWORD_ELSE ncl? (instruction | END)

assignment ::= name_declaration OPERATOR_EQUAL expressions

name_declaration ::= identifier_ {
   mixin="se.peopleandcode.rexxintellijplugin.instructions.NameDeclaration"
}

say_instruction ::= KEYWORD_SAY expressions?
private expressions ::= expression+
expression ::= concatenation
concatenation ::= compare (OPERATOR_CONCATENATE? !keywords compare)*
compare ::= addition (compare_operators addition)?
private compare_operators
    ::= OPERATOR_EQUAL
    | OPERATOR_NOT_EQUAL
    | OPERATOR_GREATERTHAN
    | OPERATOR_LESSTHAN
    | OPERATOR_GREATERTHAN_EQUAL
    | OPERATOR_LESSTHAN_EQUAL

addition ::= subtraction_ (OPERATOR_PLUS subtraction_)*
private subtraction_ ::= multiplication (subtraction)*
left subtraction ::= OPERATOR_SUBTRACT multiplication
multiplication ::= division_ (OPERATOR_MULTIPLY division_)*
private division_ ::= expressionTerm division*
left division ::= OPERATOR_DIVIDE expressionTerm

expressionTerm
    ::= stringLiteral
    | numericConstant
    | functionCall
    | methodCall
    | stem
    | variable_
    | parentheticalExpression

stem ::= variable_ (DOT EXCLAMATION? NUMBER_INT? IDENTIFIER)+
functionCall ::= variable_ TOKEN_LEFT comma_seperated_arguments TOKEN_RIGHT
private comma_seperated_arguments ::= expression? (COMMA expression?)*
methodCall ::= variable_ TILDE IDENTIFIER TOKEN_LEFT expression? (COMMA expression?)* TOKEN_RIGHT
parentheticalExpression ::= TOKEN_LEFT expression TOKEN_RIGHT
stringLiteral ::= STRING
numericConstant ::= integerConstant | decimalConstant | scientificConstant
integerConstant ::= NUMBER_INT
decimalConstant ::= NUMBER_DECIMAL
scientificConstant ::= NUMBER_SCIENTIFIC
private variable_ ::= variable | global
variable ::= identifier_ {
    mixin="se.peopleandcode.rexxintellijplugin.expressions.Variable"
}
global ::= DOT IDENTIFIER

identifier_ ::= IDENTIFIER | keywords ;

private keywords
    ::= KEYWORD_ADDRESS
    |  KEYWORD_ARG
    |  KEYWORD_VAR
    |  KEYWORD_VALUE
    |  KEYWORD_WITH
    |  KEYWORD_CALL
    |  KEYWORD_DO
    |  KEYWORD_DROP
    |  KEYWORD_ELSE
    |  KEYWORD_END
    |  KEYWORD_EXIT
    |  KEYWORD_EXPOSE
    |  KEYWORD_FORWARD
    |  KEYWORD_GUARD
    |  KEYWORD_IF
    |  KEYWORD_INTERPRET
    |  KEYWORD_ITERATE
    |  KEYWORD_LEAVE
    |  KEYWORD_LOOP
    |  KEYWORD_NOP
    |  KEYWORD_NUMERIC
    |  KEYWORD_OPTIONS
    |  KEYWORD_OTHERWISE
    |  KEYWORD_PARSE
    |  KEYWORD_PROCEDURE
    |  KEYWORD_PULL
    |  KEYWORD_PUSH
    |  KEYWORD_QUEUE
    |  KEYWORD_RAISE
    |  KEYWORD_REPLY
    |  KEYWORD_RETURN
    |  KEYWORD_SAY
    |  KEYWORD_SELECT
    |  KEYWORD_SOURCE
    |  KEYWORD_SIGNAL
    |  KEYWORD_THEN
    |  KEYWORD_TRACE
    |  KEYWORD_USE
    |  KEYWORD_WHILE
