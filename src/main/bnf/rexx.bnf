{
    parserClass="se.peopleandcode.rexxintellijplugin.gen.RexxParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Rexx"
    psiImplClassSuffix="Impl"
    psiPackage="se.peopleandcode.rexxintellijplugin.gen.psi"
    psiImplPackage="se.peopleandcode.rexxintellijplugin.gen.impl"
    elementTypeHolderClass="se.peopleandcode.rexxintellijplugin.gen.RexxTokens"
    elementTypeClass="se.peopleandcode.rexxintellijplugin.RexxElementType"
    tokenTypeClass="se.peopleandcode.rexxintellijplugin.RexxTokenType"
    tokens=[
        WHITE_SPACE="regexp:([ \t]|,[\n])+"
        TERMINATOR="regexp:[\n;]+"
        // MAJOR TOKEN TYPES
        // TOKEN_NULL
        //     TOKEN_BLANK
        //     TOKEN_SYMBOL
        //     TOKEN_LITERAL
        //     TOKEN_OPERATOR
        //     TOKEN_EOC
        //     TOKEN_COMMA
        //     TOKEN_PREFIX
        TOKEN_LEFT="("
        TOKEN_RIGHT=")"
        //     TOKEN_POINT
        //     TOKEN_COLON
        //     TOKEN_TILDE
        //     TOKEN_DTILDE
        //     TOKEN_SQLEFT
        //     TOKEN_SQRIGHT
        //     TOKEN_DCOLON
        //     TOKEN_CONTINUE
        //     TOKEN_ASSIGNMENT

        // OPERATORS
        OPERATOR_PLUS="regexp:[+]"
        OPERATOR_SUBTRACT="regexp:-"
        OPERATOR_MULTIPLY="regexp:[*]"
        OPERATOR_DIVIDE="regexp:/"
        //OPERATOR_INTDIV="regexp:\\\\"
        OPERATOR_REMAINDER="regexp:%"
        OPERATOR_POWER="regexp:[*][*]"
        OPERATOR_CONCATENATE="regexp:[|][|]"
        OPERATOR_AND="regexp:&&"

        EQ = '='
        NEQ1 = '\='
        NEQ2 = '<>'
        NEQ3 = '><'
        GT = '>'
        LT = '<'
        GTE = '>='
        LTE = '<='
        ALT_GT = '\>'
        ALT_LT = '\<'
        
        STRICT_EQ = '=='
        STRICT_NEQ = '\=='
        STRICT_GT = '>>'
        STRICT_LT = '<<'
        STRICT_GTE = '>>='
        STRICT_LTE = '<<='
        STRICT_ESC_GT = '\>>'
        STRICT_ESC_LT = '\<<'

        // Bitwise
        OPERATOR_BITWISE_AND="regexp:&"
        OPERATOR_OR="regexp:[|]"
        OPERATOR_XOR="regexp:\^\^"

        ADDRESS="regexp:[Aa][Dd][Dd][Rr][Ee][Ss][Ss]"
        ARG="regexp:[Aa][Rr][Gg]"
        VAR="regexp:[Vv][Aa][Rr]"
        VALUE="regexp:[Vv][Aa][Ll][Uu][Ee]"
        WITH="regexp:[Ww][Ii][Tt][Hh]"
        CALL="regexp:[Cc][Aa][Ll][Ll]"
        DO="regexp:[Dd][Oo]"
        DROP="regexp:[Dd][Rr][Oo][Pp]"
        ELSE="regexp:[Ee][Ll][Ss][Ee]"
        END="regexp:[Ee][Nn][Dd]"
        EXIT="regexp:[Ee][Xx][Ii][Tt]"
        EXPOSE="regexp:[Ee][Xx][Pp][Oo][Ss][Ee]"
        FORWARD="regexp:[Ff][Oo][Rr][Ww][Aa][Rr][Dd]"
        GUARD="regexp:[Gg][Uu][Aa][Rr][Dd]"
        IF="regexp:[Ii][Ff]"
        INTERPRET="regexp:[Ii][Nn][Tt][Ee][Rr][Pp][Rr][Ee][Tt]"
        ITERATE="regexp:[Ii][Tt][Ee][Rr][Aa][Tt][Ee]"
        LEAVE="regexp:[Ll][Ee][Aa][Vv][Ee]"
        LOOP="regexp:[Ll][Oo][Oo][Pp]"
        NOP="regexp:[Nn][Oo][Pp]"
        NUMERIC="regexp:[Nn][Uu][Mm][Ee][Rr][Ii][Cc]"
        OPTIONS="regexp:[Oo][Pp][Tt][Ii][Oo][Nn][Ss]"
        OTHERWISE="regexp:[Oo][Tt][Hh][Ee][Rr][Ww][Ii][Ss][Ee]"
        PARSE="regexp:[Pp][Aa][Rr][Ss][Ee]"
        PROCEDURE="regexp:[Pp][Rr][Oo][Cc][Ee][Dd][Uu][Rr][Ee]"
        PULL="regexp:[Pp][Uu][Ll][Ll]"
        PUSH="regexp:[Pp][Uu][Ss][Hh]"
        QUEUE="regexp:[Qq][Uu][Ee][Uu][Ee]"
        RAISE="regexp:[Rr][Aa][Ii][Ss][Ee]"
        REPLY="regexp:[Rr][Ee][Pp][Ll][Yy]"
        RETURN="regexp:[Rr][Ee][Tt][Uu][Rr][Nn]"
        SAY="regexp:[Ss][Aa][Yy]"
        SELECT="regexp:[Ss][Ee][Ll][Ee][Cc][Tt]"
        SOURCE="regexp:[Ss][Oo][Uu][Rr][Cc][Ee]"
        SIGNAL="regexp:[Ss][Ii][Gg][Nn][Aa][Ll]"
        THEN="regexp:[Tt][Hh][Ee][Nn]"
        TRACE="regexp:[Tt][Rr][Aa][Cc][Ee]"
        USE="regexp:[Uu][Ss][Ee]"
        WHILE="regexp:[Ww][Hh][Ii][Ll][Ee]"
        WHEN="regexp:[Ww][Hh][Ee][Nn]"


        // Comments
        SHEBANG="regexp:[#][!][^\n]*"
        LINE_COMMENT="regexp:--[^\n]*"
        MULTILINE_COMMENT="regexp:[/][*]([^*]+|[*]+[^/*])*[*]+[/]"

        // complex

        STRING="regexp:\"[^\"\n]*\"|'[^'\n]*'"
        IDENTIFIER="regexp:[_!?a-zA-Z][a-zA-Z0-9_]*"


        // Numbers
        NUMBER_BINARY="regexp:0b[01]+"
        NUMBER_INT="regexp:[0-9]+"
        NUMBER_DECIMAL="regexp:[0-9]+[.][0-9]+"
        NUMBER_SCIENTIFIC="regexp:[0-9]*[.][0-9]+([eE][+-]?[0-9]+)"
        NUMBER_HEXADECIMAL="regexp:0[xX][0-9a-fA-F]+"

        // OO

        CLASS="regexp:::class"
        ATTRIBUTE="regexp:::attribute"
        METHOD="regexp:::method"
        DOT="regexp:[.]"
        EXCLAMATION="regexp:[!]"
        TILDE="regexp:[~]"
        COMMA="regexp:[,]"
        COLON="regexp:[:]"
    ]
    extends(".*expr")=expr
}

/*program*/
rexx_file ::= ncl? instruction_list? END?
private ncl ::=  <<eof>> | null_clause+
private null_clause ::= terminator /*label_list?
private label_list ::= (label_instruction terminator)+*/
private terminator ::= TERMINATOR
private instruction_list ::= instruction+
private instruction ::= group | single_instruction ncl
private group ::= instruction_block | if_instruction | select_instruction
select_instruction ::= SELECT /* group_option* */ ncl select_body /* group_handler? */ END ncl?
select_body ::= when_branch+ otherwise_branch?
when_branch ::= WHEN expr ncl? then
otherwise_branch ::= OTHERWISE ncl? /*ncl not optional in spec*/ instruction*
private command ::= expression_instruction
private keyword_instruction
    ::= address_instruction
    | arg_instruction
    | call_instruction
    /*| drop*/
    | exit_instruction
    /*| interop*/
    | iterate_instruction
    /*| leave*/
    /*| nop*/
    | numeric_instruction
    /*| options*/
    | parse_instruction
    /*| procedure */
    | return_instruction
    | say_instruction
    | signal_instruction
    | trace_instruction
private single_instruction
    ::= label_instruction
    | assignment
    | keyword_instruction
    | command
arg_instruction ::= ARG template_list?
private template_list
    ::= template (COMMA template?)*
    | (COMMA template?)+
private template ::= trigger | target
private trigger ::= pattern | positional
private target ::= name_declaration | DOT
private pattern ::= stringLiteral /*| vrefp*/
private positional ::= absolute_positional | relative_positional
private absolute_positional ::= numericConstant | EQ position
private position ::= numericConstant  /*| vrefp*/
private relative_positional ::= (OPERATOR_PLUS | OPERATOR_SUBTRACT) position
numeric_instruction ::= NUMERIC IDENTIFIER integerConstant
iterate_instruction ::= ITERATE variable_?
label_instruction ::= name_declaration COLON (PROCEDURE (EXPOSE IDENTIFIER)? DOT?)?
return_instruction ::= RETURN expr?

signal_instruction ::= SIGNAL expr

trace_instruction ::= TRACE ("o"|"i"|"r")

exit_instruction ::= EXIT expr?
call_instruction ::= CALL
    ( /*callon_spec
    |*/ (taken_constant /*| vref */) expression_list?
    )

address_instruction ::= ADDRESS expr

expression_instruction
    ::= &IDENTIFIER expr
    | &stringLiteral expr


instruction_block ::= do_specification ncl
    instruction_list?
    do_ending
    { pin = do_specification }
private do_specification ::= DO /*[group_option+]*/
    ( dorep
    | conditional
    | dorep conditional
    )?
private conditional ::= 'WHILE' whileexpr | 'UNTIL' untilexpr
private untilexpr ::= expr
private whileexpr ::= expr
private dorep ::= 'FORVER' | repetitor
private repetitor ::= assignment | expr | over | 'FOREVER'
private over
    ::= name_declaration 'OVER' expr
    | numericConstant 'OVER'
    /*| CONST_SYMBOL 'OVER'*/
private do_ending ::= END name_declaration? ncl

parse_instruction
    ::= PARSE translation? parse_type template_list*
private translation ::= 'CASELESS' ['UPPER' | 'LOWER'] | ('UPPER' | 'LOWER')
private parse_type
    ::= parse_key
    | parse_value
    | parse_var
    | term_expr

private parse_key
    ::= ARG
    | PULL
    | SOURCE
    | 'LINEIN'
    | 'VERSION'

private parse_value ::= VALUE expr? WITH
private parse_var ::= VAR name_declaration

if_instruction ::= IF expr ncl? then else?
private then ::= THEN ncl? (instruction | END)
private else ::= ELSE ncl? (instruction | END)

assignment ::= name_declaration '=' expr

name_declaration ::= identifier_ {
   mixin="se.peopleandcode.rexxintellijplugin.instructions.NameDeclaration"
}

say_instruction ::= SAY expr?
/*
Compact expressions, soon ish:
https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
*/


expr
    ::= alias_expr
    | and_expr
    | comparison_expr
    | concatenation_expr
    | addition_expr
    | multiplication_expr
    | power_expr
    | prefix_expr
    | term_expr

alias_expr ::= expr or_operator expr
or_operator ::= OPERATOR_OR | OPERATOR_AND
and_expr ::= expr OPERATOR_BITWISE_AND expr
comparison_expr ::= expr comparison_operator expr
concatenation_expr ::= expr (OPERATOR_CONCATENATE | &expr ) expr
addition_expr ::= expr additive_operator expr
additive_operator ::= OPERATOR_PLUS | OPERATOR_SUBTRACT
multiplication_expr ::= expr multiplicative_operator expr
multiplicative_operator
    ::= OPERATOR_MULTIPLY
    | OPERATOR_DIVIDE
    | '//'
    | OPERATOR_REMAINDER
power_expr ::= expr '**' expr
prefix_expr ::= prefix  expr
private prefix
    ::= OPERATOR_PLUS
    | OPERATOR_SUBTRACT
    | "\\"
term_expr ::=
    simple_term (DOT simple_term?)* message_call*
private comparison_operator ::= normal_compare | strict_compare
private normal_compare ::=  EQ | NEQ1 | NEQ2 | NEQ3 | GT | LT | GTE | LTE | ALT_GT | ALT_LT
private strict_compare ::= STRICT_EQ | STRICT_NEQ | STRICT_GT | STRICT_LT | STRICT_GTE | STRICT_LTE | STRICT_ESC_GT | STRICT_ESC_LT


stringLiteral ::= STRING
private numericConstant ::= integerConstant | decimalConstant | scientificConstant
integerConstant ::= NUMBER_INT
decimalConstant ::= NUMBER_DECIMAL
scientificConstant ::= NUMBER_SCIENTIFIC
private variable_ ::= variable | global
variable ::= identifier_ {
    mixin="se.peopleandcode.rexxintellijplugin.expressions.Variable"
}
global ::= DOT IDENTIFIER
private symbol ::= variable | global /* == const_symbol */ | numericConstant

private simple_term
    ::= stringLiteral
    | invoke
    | symbol
    | indexed
    | parentheticalExpression
    | initializer

parentheticalExpression ::= TOKEN_LEFT expr TOKEN_RIGHT

private message_call ::= TILDE TILDE? method_name arguments?
private method_name ::= /*taken_constant*/ IDENTIFIER (COLON variable_)?
invoke ::= (symbol | stringLiteral) arguments
private arguments ::= TOKEN_LEFT expression_list? TOKEN_RIGHT
private expression_list
    ::= expr (COMMA expr?)*
    | (COMMA expr?)+
private indexed ::= symbol | stringLiteral indices
private indices ::= '[' expression_list? ']'
private initializer ::= '[' expression_list ']'
private taken_constant ::= symbol | stringLiteral

identifier_ ::= IDENTIFIER | keywords ;
private keywords
    ::= ADDRESS
    |  ARG
    |  VAR
    |  VALUE
    |  CALL
    |  DO
    |  DROP
    |  ELSE
    |  END
    |  EXIT
    |  EXPOSE
    |  FORWARD
    |  GUARD
    |  IF
    |  INTERPRET
    |  ITERATE
    |  LEAVE
    |  LOOP
    |  NOP
    |  NUMERIC
    |  OPTIONS
    |  OTHERWISE
    |  PARSE
    |  PROCEDURE
    |  PULL
    |  PUSH
    |  QUEUE
    |  RAISE
    |  REPLY
    |  RETURN
    |  SAY
    |  SELECT
    |  SOURCE
    |  SIGNAL
    |  TRACE
    |  USE
    |  WHILE
